|===
| Padrão de Projeto | Tipo          | Estrutura                                                                                     | Exemplo Simples                                                                                                                                                                                                                           | Uso na Main Class                                                                                                                                                                                                             | Usos Comuns

| Factory Method     | Criação       | Define uma interface para criar objetos, mas permite que as subclasses decidam qual classe instanciar. | `interface Animal { void speak(); } class Dog implements Animal { public void speak() { System.out.println("Woof!"); } } class AnimalFactory { Animal createAnimal() { return new Dog(); } }`                                                                        | `public class Main { public static void main(String[] args) { AnimalFactory factory = new AnimalFacto); } }`                                                                 | Quando o tipo de objeto a ser criado é determinado em tempo de execução, dependendo das necessidades.

| Abstract Factory   | Criação       | Cria famílias de objetos relacionados sem especificar suas classes concretas.               | `interface Button { void click(); } class MacButton implements Button { public void click() { System.out.println("Mac button clicked"); } } interface GUIFactory { Button createButton(); } class MacFactory implements GUIFactory { public Button createButton() { return new MacButton(); } }` | `public class Main { public static void main(String[] args) { GUIFactory factory = new MacFactory(); Button button = factory.createButton(); button.click(); } }`                                                              | Quando você precisa de famílias de objetos relacionados e deseja que o código cliente seja independente da forma como os objetos são criados.

| Builder            | Criação       | Constrói um objeto complexo passo a passo.                                                   | `class Pizza { private String size; private String crust; private String topping; public Pizza(String size, String crust, String topping) { this.size = size; this.crust = crust; this.topping = topping; } } class PizzaBuilder { private String size; private String crust; private String topping; public PizzaBuilder size(String size) { this.size = size; return this; } public PizzaBuilder crust(String crust) { this.crust = crust; return this; } public PizzaBuilder topping(String topping) { this.topping = topping; return this; } public Pizza build() { return new Pizza(size, crust, topping); } }` | `public class Main { public static void main(String[] args) { Pizza pizza = new PizzaBuilder().size("Large").crust("Thin").topping("Cheese").build(); } }`                                                                         | Usado para construir objetos complexos, onde a construção passo a passo é necessária (exemplo: construção de veículos, pizzas, etc.).

| Prototype          | Criação       | Cria novos objetos copiando um objeto existente.                                             | `class Prototype implements Cloneable { private String data; public Prototype(String data) { this.data = data; } public Prototype clone() { try { return (Prototype) super.clone(); } catch (CloneNotSupportedException e) { return null; } } }`                                                    | `public class Main { public static void main(String[] args) { Prototype original = new Prototype("Data"); Prototype clone = original.clone(); System.out.println(clone); } }`                                                                                     | Quando você precisa criar novos objetos copiando um objeto existente, e não instanciando-os novamente. Exemplo: clonar objetos em uma aplicação.

| Adapter            | Estrutural    | Converte a interface de uma classe em outra que o cliente espera.                           | `interface MediaPlayer { void play(String filename); } class MP3Player implements MediaPlayer { public void play(String filename) { System.out.println("Playing MP3: " + filename); } } interface AdvancedMediaPlayer { void playMP4(String filename); } class MP4Player implements AdvancedMediaPlayer { public void playMP4(String filename) { System.out.println("Playing MP4: " + filename); } } class MediaAdapter implements MediaPlayer { private AdvancedMediaPlayer advancedMusicPlayer; public MediaAdapter(AdvancedMediaPlayer advancedMusicPlayer) { this.advancedMusicPlayer = advancedMusicPlayer; } public void play(String filename) { advancedMusicPlayer.playMP4(filename); } }` | `public class Main { public static void main(String[] args) { MediaPlayer player = new MediaAdapter(new MP4Player()); player.play("video.mp4"); } }`                                                                                 | Usado quando é necessário adaptar uma interface incompatível para que se encaixe em uma API existente. Exemplo: adaptar diferentes tipos de mídia.

| Facade             | Estrutural    | Fornece uma interface simplificada para um subsistema complexo.                             | `class CPU { void freeze() { System.out.println("Freezing CPU"); } } class Memory { void load() { System.out.println("Loading Memory"); } } class ComputerFacade { private CPU cpu = new CPU(); private Memory memory = new Memory(); public void startComputer() { cpu.freeze(); memory.load(); } }`              | `public class Main { public static void main(String[] args) { ComputerFacade computer = new ComputerFacade(); computer.startComputer(); } }`                                                                                 | Para fornecer uma interface mais simples para sistemas complexos. Exemplo: simplificar interações com subsistemas complexos, como no início de um computador.

| Decorator          | Estrutural    | Adiciona funcionalidades a um objeto de forma dinâmica.                                     | `interface Coffee { double cost(); } class SimpleCoffee implements Coffee { public double cost() { return 5.0; } } class MilkDecorator implements Coffee { private Coffee coffee; public MilkDecorator(Coffee coffee) { this.coffee = coffee; } public double cost() { return coffee.cost() + 1.5; } }`                                 | `public class Main { public static void main(String[] args) { Coffee coffee = new SimpleCoffee(); coffee = new MilkDecorator(coffee); System.out.println("Total cost: " + coffee.cost()); } }`                                                                    | Usado quando você precisa adicionar comportamentos adicionais a objetos sem modificar sua estrutura original. Exemplo: adicionar recursos a objetos de forma flexível.

| Observer           | Comportamental | Define uma dependência de um-para-muitos entre objetos, de modo que quando um objeto muda de estado, todos os seus dependentes são notificados. | `interface Observer { void update(String message); } class ConcreteObserver implements Observer { public void update(String message) { System.out.println("Message: " + message); } } class Subject { private List<Observer> observers = new ArrayList<>(); public void addObserver(Observer observer) { observers.add(observer); } public void notifyObservers(String message) { for (Observer observer : observers) { observer.update(message); } } }`                                      | `public class Main { public static void main(String[] args) { Subject subject = new Subject(); Observer observer1 = new ConcreteObserver(); subject.addObserver(observer1); subject.notifyObservers("New message"); } }`                                                                                      | Para eventos em que vários objetos precisam ser notificados sobre mudanças de estado em outro objeto. Exemplo: sistemas de eventos, atualizações de interfaces gráficas.

| Strategy           | Comportamental | Define uma família de algoritmos, encapsula cada um e permite que sejam intercambiados.    | `interface PaymentStrategy { void pay(int amount); } class CreditCardPayment implements PaymentStrategy { public void pay(int amount) { System.out.println("Paid " + amount + " using Credit Card"); } } class PayPalPayment implements PaymentStrategy { public void pay(int amount) { System.out.println("Paid " + amount + " using PayPal"); } }` | `public class Main { public static void main(String[] args) { PaymentStrategy strategy = new PayPalPayment(); strategy.pay(100); } }`                                                                                         | Para permitir que o algoritmo de um processo seja alterado em tempo de execução. Exemplo: escolha de métodos de pagamento, estratégias de movimentação em jogos.

| Command            | Comportamental | Encapsula uma solicitação como um objeto, permitindo parametrizar os clientes com filas de pedidos, registros de logs e operações de cancelamento. | `interface Command { void execute(); } class LightOnCommand implements Command { private Light light; public LightOnCommand(Light light) { this.light = light; } public void execute() { light.turnOn(); } } class RemoteControl { private Command command; public void setCommand(Command command) { this.command = command; } public void pressButton() { command.execute(); } }`                                           | `public class Main { public static void main(String[] args) { Light light = new Light(); Command lightOn = new LightOnCommand(light); RemoteControl remote = new RemoteControl(); remote.setCommand(lightOn); remote.pressButton(); } }`                                                              | Quando você precisa separar a solicitação de uma operação da execução dessa operação, como em sistemas de undo/redo, processamento de comandos em sistemas.
|===
